# React Hooks

## yarn

[https://yarn.bootcss.com/](https://yarn.bootcss.com/)

`yarn` 是 facebook 开源的一个 npm 客户端，相比较默认的 npm 客户端，yarn 做了很多机制上的优化，比如缓存、安装速度、完整性校验等等，在使用体验上面比较友好，被很多知名框架选为默认的依赖管理工具，后面我们也默认使用 yarn。

要安装 yarn 也很简单

```
npm i yarn -g
```

yarn 的基本功能和 npm 是对应的，但是参数略有不同，下面是一些常用命令的对比

### 添加依赖

yarn

```
yarn add react
```

npm

```
npm i react
```

### 添加开发依赖

yarn

```
yarn add @types/node --dev
```

npm

```
npm i @types/node --save-dev
```

### 删除依赖

yarn

```
yarn remove react
```

npm

```
npm remove react
```

## npx

[npx 使用教程](https://www.ruanyifeng.com/blog/2019/02/npx.html)

npm 从 5.2 版本开始增加了 `npx` 命令，它有很多用处，这里介绍一下它的主要适用场景。

### 调用项目安装模块

有时候我们发布 `typescript` 开发的工程给其他人用，在使用之前需要使用 `tsc` 命令进行编译，但是需要对方先全局安装 `typescript` 模块才能获得 `tsc` 命令，不是很方便。

或者是将 `typescript` 安装成项目的一个依赖，这样它就会在 `node_modules/.bin/` 目录下创建对应的可执行命令脚本，然后通过 `node_modules/.bin/tsc` 来执行，很明显也不是很友好。也可以在 `package.json` 的 `scripts` 标签中配置相关的指令来调用。

如果是通过 `npx`，则可以直接执行 `npx tsc`，`npx` 会帮我们自动执行 `node_modules/.bin/tsc`。

### 避免全局安装模块

对于上面这种情况，我们也可以选择不将 `typescript` 安装为一个项目依赖，而是直接执行 `npx tsc`，`npx` 会在后台去下载 `typescript` 到临时目录，然后调用它来执行我们的命令，使用完毕之后再删除。

有多时候我们只是想临时用一下某个全局模块，通过 npx 可以避免全局污染，而且每次都是基于最新的模块版本。

## create-react-app

[https://www.html.cn/create-react-app/](https://www.html.cn/create-react-app/)

之前我们学习了多种组织 `React` 工程的方式，比如通过原生 `ES Modules` 加载以及自己配置 `webpack` 构建流程，目的是让大家更好了解 `React` 的基本原理，在实际开发中我们可以借助于脚手架工具来快速创建一个配置好的 `React` 项目。

`create-react-app` 是 `React` 团队官方推出的脚手架工具，它提供了很多开箱即用的配置，让我们可以把精力集中在具体的业务开发上面。要使用脚手架非常简单，通过下面的命令来即可创建一个使用 `TypeScript` 的 `React` 工程。

```
npx create-react-app react-app --template typescript
```

我们可以直接在创建好的 `react-app` 项目中使用 `TypeScript`、`CSS Modules` 等我们熟悉的技术来编写代码了，整个的构建流程都已经帮我们封装好的。`create-react-app` 默认没有支持 `less`，我们暂时先使用 `CSS` + `Modules` 的方式来编写样式，或者迁移到 `SCSS`。

`src` 就是我们存放源代码的目录，除了 `react-app-env.d.ts`（定义自定义模块的类型如图片、样式），其他的基本都可以替换成我们自己的内容。

### CSS Modules

`create-react-app` 会把 `.module.css` 结尾的文件当成 `CSS Modules` 来处理，所以如果我们想要使用该功能，只需要将组件的 css 文件命名为 `style.module.css` 这种结构，然后在组件中这样来引用

```ts
import style from './style.module.css'
```

后面的用法和之前就完全一样了，对于不是以 `.module.css` 结尾的 css 文件，会被当做普通 css 处理，不会做类名转换。

### 添加代理

`create-react-app` 默认支持的代理功能比较简单，只需要在 `package.json` 中添加一个属性

```json
"proxy": "http://localhost:4000"
```

这样本地开发环境无法被响应的请求就会被代理到 proxy 的地址，用于访问我们后端的 API 接口。

### 启动调试

```
yarn start
```

### 构建

```
yarn build
```

### axios

[https://github.com/axios/axios](https://github.com/axios/axios)

`axios` 是一个知名的 http 请求库，同时支持浏览器端和 Node.js 端，`axios` 提供了很多功能强大的 API，比如拦截器、取消请求、传输进度等，非常方便我们对网络请求进行控制，后面的项目中我们都会使用这个库来请求 API。

## 函数式组件

我们前面学习的 `React` 组件都是基于类的，类相对来说比较复杂，而且内部的逻辑通常难以复用，对于一些简单场景，我们可以创建函数式组件，组件的定义就是一个函数，如下面的例子：

```ts
interface IComment {
  author: string
  text: string
  date: string
}

function Comment(props: IComment) {
  const onClick = () => {
    console.log(props)
  }

  return (
    <div className='comment' onClick={onClick}>
      <div className='comment-author'>{props.author}</div>
      <div className='comment-text'>{props.text}</div>
      <div className='comment-date'>{props.date}</div>
    </div>
  )
}
```

从上面的例子我们可以看到，整个组件的代码非常简洁，相对于类组件来说简单清晰了很多，但是普通的函数式组件也有一些不同，比如没有 `this`、没有内部状态 `state`、没有生命周期，只能通过 `props` 从外部传入数据，每次组件的更新都会导致定义组件的函数重新执行。

## Hook

Hook 是 React 16.8 的新增属性，它可以让我们在不编写 class 的情况下使用 state 以及其他的 React 特性，Hook 就相当于添加了内部状态的函数式组件，Hook 已经成为 React 的主流发展方向，在后面的项目中我们也会全面拥抱 Hook。

### State Hook

```ts
function Counter() {
  const [count, setCount] = React.useState(0)

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  )
}
```

上面的例子 `useState` 就是一个 `Hook`，通过在函数式组件里面调用它来添加一些内部 `state`，前面我们讲到，函数式组件在刷新时会重复执行函数，意味着每一次我们在页面上看到的组件都是函数最新执行返回的结果，函数内部的变量都是当前作用域的，可以把每次函数式组件的更新当成一帧。而通过 `useState`，React 在重复渲染时会保留这个 `state`。`useState` 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数或其他一些地方调用这个函数。它类似于类组件的 `this.setState`，不过不同的是

> useState 更新状态不会把新的 state 和旧的 state 合并，而是会直接覆盖整个状态，如果 state 中保存的是一个对象，在更新的时候需要注意使用解构赋值来确保修改 state 的完整性

`useState` 唯一的参数就是初始 `state`，我们可以在 state 中存放对象、数组，也可以多次使用 `useState` 来创建多个 `state`

`Hook` 就是可以让你在函数式组件内部“钩入” `React state` 以及生命周期等特性的函数，`Hook` 不能在类组件中使用。

### Effect Hook

我们已经写过很多在 React 组件中进行数据获取、订阅事件甚至修改 DOM 之类的操作，这些行为在 React 中统一被称为“副作用”，`useEffect` 就是 React 内置的一个 `Effect Hook`，给函数增加了操作副作用的能力，它跟类组件中的 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 具有相同的用途，可以实现生命周期的效果，不过被合并成了一个 API。

```ts
export default function Effect() {
  const [count, setCount] = React.useState(0)

  React.useEffect(() => {
    document.title = `You clicked ${count} times`
  })

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  )
}
```

现在对前面的 `Counter` 做一些修改，我们加入了 `useEffect` 来执行副作用，当组件每一次刷新的时候会同时改变页面的标题。当你调用 `useEffect` 时就是在告诉 React 在完成 DOM 的更改后运行你的副作用函数，由于副作用是在组件内声明的，所以它可以访问到组件的 props 和 state，默认情况下，React 会在每次渲染后调用副作用函数，包括第一次渲染的时候。

`useEffect` 还可以通过第二个参数传入依赖，只有当依赖的状态发生变化时才会执行副作用，如

```ts
export default function Effect() {
  const [count, setCount] = React.useState(0)
  const [value, setValue] = React.useState(0)

  React.useEffect(() => {
    console.log(count)
    document.title = `You clicked ${count} times`
  }, [count])

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
      <p>Value {value}</p>
      <button onClick={() => setValue(value + 1)}>Increase</button>
    </div>
  )
}
```

上面的例子我们定义了两个状态，`count` 和 `value`，并且传入了 `[count]` 作为副作用函数的依赖，也就是当 `count` 发生变化时才会执行这个副作用函数，当修改 `value` 时不会执行，如果我们去掉 `[count]`，那么不管修改哪个状态都会引起副作用函数的执行，显然不符合我们的期望。

如果第二个参数传入一个空数组 `[]`，那么这个副作用函数只会在组件挂载的时候执行一次，相当于类组件的 `componentDidMount`，`useEffect` 可以返回一个函数用来执行清除副作用的操作，React 会在卸载组件的时候执行清理操作，相当于类组件的 `componentWillUnmount`，如

```ts
React.useEffect(() => {
  console.log('mount')
  return () => {
    console.log('unount')
  }
}, [])
```

### 理解 Hook

理解 `Hook` 的工作机制至关重要，前面我们讲到，函数组件每次刷新都会引起函数的重新执行，也就意味着每一次函数内部的变量都是重新初始化的，而 `Hook` 可以让函数组件在刷新的时候保留一些状态，当我们修改状态之后，组件函数会被重新执行，在重新执行的函数上下文拿到新的状态，下面我们通过几个例子来理解一下。

```ts
function Example3() {
  const [count, setCount] = React.useState(0)

  const handleClick = () => {
    setTimeout(() => {
      setCount(count + 1)
    }, 2000)
  }

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={handleClick}>Click me</button>
    </div>
  )
}
```

这个例子里面我们添加了一个状态 `count`，当点击按钮时我们通过 `setTimeout` 延时 2 秒钟来修改 `count` 的值，如果点击一下按钮，过 2 秒钟会看到 `count` 变成了 1，如果我们快速连续点击 3 次，按照直觉，`count` 应该变成 `3`，但是你会发现过了两秒钟之后 `count` 依然是 `1`。

如果把函数的每次执行理解为一帧，虽然我们连续点击了 3 次，但是这三次的 `setTimeout` 是在同一帧内执行的，它们的 `count` 都是初始值 `0`，所以最后看到的结果还是 `1`，如果想要得到期望的结果 `3`，可以给 `setCount` 传递一个函数，它可以接收上一次的状态，如：

```ts
export default function Example4() {
  const [count, setCount] = React.useState(0)

  const handleClick = () => {
    setTimeout(() => {
      setCount((count) => count + 1)
    }, 2000)
  }

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={handleClick}>Click me</button>
    </div>
  )
}
```

再来看一个更复杂些的例子，假如我们想要在 `Hook` 中编写一个计数器的功能，在组件挂载之后就开始计数，每隔 1 秒钟增加 1，代码写起来可能会是这样

```ts
export default function Example5() {
  const [count, setCount] = React.useState(0)

  React.useEffect(() => {
    let timer = setInterval(() => {
      console.log(count, Date.now())
      setCount(count + 1)
    }, 1000)
    return () => clearInterval(timer)
  }, [])

  return (
    <div>
      <p>Count {count}</p>
    </div>
  )
}
```

代码并没有按照我们期望的结果工作，虽然控制台一直在打印数据，但是`count` 始终显示为 `1`，这个是因为我们 `useEffect` 传入的依赖为 `[]`，也就是说副作用函数只会在组件挂载的时候执行一次，`setInterval` 取到的 `count` 一直都是第一帧的初始值 `0`，和前面的例子类似，要解决这个问题也有多种方法，比如也是给 `setCount` 传入一个函数，或者下面的方式：

```ts
export default function Example6() {
  const [count, setCount] = React.useState(0)

  React.useEffect(() => {
    console.log('new effect')
    let timer = setInterval(() => {
      console.log(count, Date.now())
      setCount(count + 1)
    }, 1000)
    return () => clearInterval(timer)
  }, [count])

  return (
    <div>
      <p>Count {count}</p>
    </div>
  )
}
```

在这个例子里面我们把 `count` 添加进了副作用函数的依赖，这样每次 `count` 更新之后就会重新执行副作用，清除前一次的定时器，发起一次新的定时器，`count` 取到的也是最新的状态，实现一个正常的计数效果。

### 额外的 Hook

React 还提供了一些其他的 Hook，通常用来做一些性能优化方便的工作，暂时不在我们的学习范围之内。

## 课后任务

使用 `Hook` 改写时间胶囊，要求

- 完全基于 `Hook` 来编写组件
- 原有业务逻辑不变
- 增加更改主题的功能，将原网页的`回胶囊日记`处的按钮更改成更换主题的按钮。
  - 点击`更改主题`，选设定好的颜色，将网页其他的红色按钮全部更改为设定好的颜色
- 使用 `create-react-app` 脚手架创建工程
- 使用 `yarn` 管理依赖
- 使用 `CSS Modules`
- 使用 `axios` 进行网络请求
- 如果使用了 `MobX`，需要自行查阅文档实现和 `Hook` 的结合使用
- 解决脚手架警告的代码问题
- README 记录作业问题和思路
